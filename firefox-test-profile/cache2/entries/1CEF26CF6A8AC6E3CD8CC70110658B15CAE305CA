(function(window) {

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "(createSpecFilter|createStartFn)" }] */

'use strict'

// Save link to native Date object
// before it might be mocked by the user
var _Date = Date

/**
 * Decision maker for whether a stack entry is considered external to jasmine and karma.
 * @param  {String}  entry Error stack entry.
 * @return {Boolean}       True if external, False otherwise.
 */
function isExternalStackEntry (entry) {
  return !!entry &&
  // entries related to jasmine and karma-jasmine:
  !/\/(jasmine-core|karma-jasmine)\//.test(entry) &&
  // karma specifics, e.g. "at http://localhost:7018/karma.js:185"
  !/\/(karma.js|context.html):/.test(entry)
}

/**
 * Returns relevant stack entries.
 * @param  {Array} stack frames
 * @return {Array}        A list of relevant stack entries.
 */
function getRelevantStackFrom (stack) {
  var filteredStack = []
  var relevantStack = []

  for (var i = 0; i < stack.length; i += 1) {
    if (isExternalStackEntry(stack[i])) {
      filteredStack.push(stack[i])
    }
  }

  // If the filtered stack is empty, i.e. the error originated entirely from within jasmine or karma, then the whole stack
  // should be relevant.
  if (filteredStack.length === 0) {
    filteredStack = stack
  }

  for (i = 0; i < filteredStack.length; i += 1) {
    if (filteredStack[i]) {
      relevantStack.push(filteredStack[i])
    }
  }

  return relevantStack
}

/**
 * Custom formatter for a failed step.
 *
 * Different browsers report stack trace in different ways. This function
 * attempts to provide a concise, relevant error message by removing the
 * unnecessary stack traces coming from the testing framework itself as well
 * as possible repetition.
 *
 * @see    https://github.com/karma-runner/karma-jasmine/issues/60
 * @param  {Object} step Step object with stack and message properties.
 * @return {String}      Formatted step.
 */
function formatFailedStep (step) {
  var relevantMessage = []
  var relevantStack = []

  // Safari/Firefox seems to have no stack trace,
  // so we just return the error message and if available
  // construct a stacktrace out of filename and lineno:
  if (!step.stack) {
    if (step.filename) {
      var stackframe = step.filename
      if (step.lineno) {
        stackframe = stackframe + ':' + step.lineno
      }
      relevantStack.push(stackframe)
    }
    relevantMessage.push(step.message)
    return relevantMessage.concat(relevantStack).join('\n')
  }

  // Remove the message prior to processing the stack to prevent issues like
  // https://github.com/karma-runner/karma-jasmine/issues/79
  var stackframes = step.stack.split('\n')
  var messageOnStack = null
  if (stackframes[0].indexOf(step.message) !== -1) {
    // Remove the message if it is in the stack string (eg Chrome)
    messageOnStack = stackframes.shift()
  }
  // Filter frames
  var relevantStackFrames = getRelevantStackFrom(stackframes)
  if (messageOnStack) {
    // Put the message back if we removed it.
    relevantStackFrames.unshift(messageOnStack)
  } else {
    // The stack did not have the step.message so add it.
    relevantStackFrames.unshift(step.message)
  }

  return relevantStackFrames.join('\n')
}

function debugUrl (description) {
  // A link to re-run just one failed test case.
  return window.location.origin + '/debug.html?spec=' + encodeURIComponent(description)
}

function SuiteNode (name, parent) {
  this.name = name
  this.parent = parent
  this.children = []

  this.addChild = function (name) {
    var suite = new SuiteNode(name, this)
    this.children.push(suite)
    return suite
  }
}

function processSuite (suite, pointer) {
  var child
  var childPointer

  for (var i = 0; i < suite.children.length; i++) {
    child = suite.children[i]

    if (child.children) {
      childPointer = pointer[child.description] = { _: [] }
      processSuite(child, childPointer)
    } else {
      if (!pointer._) {
        pointer._ = []
      }
      pointer._.push(child.description)
    }
  }
}

function getAllSpecNames (topSuite) {
  var specNames = {}

  processSuite(topSuite, specNames)

  return specNames
}

/**
 * Very simple reporter for Jasmine.
 */
function KarmaReporter (tc, jasmineEnv) {
  var currentSuite = new SuiteNode()

  var startTimeCurrentSpec = new _Date().getTime()

  function handleGlobalErrors (result) {
    if (result.failedExpectations && result.failedExpectations.length) {
      var message = 'An error was thrown in afterAll'
      var steps = result.failedExpectations
      for (var i = 0, l = steps.length; i < l; i++) {
        message += '\n' + formatFailedStep(steps[i])
      }

      tc.error(message)
    }
  }

  /**
   * Jasmine 2.0 dispatches the following events:
   *
   *  - jasmineStarted
   *  - jasmineDone
   *  - suiteStarted
   *  - suiteDone
   *  - specStarted
   *  - specDone
   */

  this.jasmineStarted = function (data) {
    // TODO(vojta): Do not send spec names when polling.
    tc.info({
      event: 'jasmineStarted',
      total: data.totalSpecsDefined,
      specs: getAllSpecNames(jasmineEnv.topSuite())
    })
  }

  this.jasmineDone = function (result) {
    result = result || {}

    // Any errors in top-level afterAll blocks are given here.
    handleGlobalErrors(result)

    // Remove functions from called back results to avoid IPC errors in Electron
    // https://github.com/twolfson/karma-electron/issues/47
    var cleanedOrder
    if (result.order) {
      cleanedOrder = {}
      var orderKeys = Object.getOwnPropertyNames(result.order)
      for (var i = 0; i < orderKeys.length; i++) {
        var orderKey = orderKeys[i]
        if (typeof result.order[orderKey] !== 'function') {
          cleanedOrder[orderKey] = result.order[orderKey]
        }
      }
    }

    tc.complete({
      order: cleanedOrder,
      coverage: window.__coverage__
    })
  }

  this.suiteStarted = function (result) {
    currentSuite = currentSuite.addChild(result.description)
    tc.info({
      event: 'suiteStarted',
      result: result
    })
  }

  this.suiteDone = function (result) {
    // In the case of xdescribe, only "suiteDone" is fired.
    // We need to skip that.
    if (result.description !== currentSuite.name) {
      return
    }

    // Any errors in afterAll blocks are given here, except for top-level
    // afterAll blocks.
    handleGlobalErrors(result)

    currentSuite = currentSuite.parent

    tc.info({
      event: 'suiteDone',
      result: result
    })
  }

  this.specStarted = function () {
    startTimeCurrentSpec = new _Date().getTime()
  }

  this.specDone = function (specResult) {
    var skipped = specResult.status === 'disabled' || specResult.status === 'pending' || specResult.status === 'excluded'
    var result = {
      fullName: specResult.fullName,
      description: specResult.description,
      id: specResult.id,
      log: [],
      skipped: skipped,
      disabled: specResult.status === 'disabled' || specResult.status === 'excluded',
      pending: specResult.status === 'pending',
      success: specResult.failedExpectations.length === 0,
      suite: [],
      time: skipped ? 0 : new _Date().getTime() - startTimeCurrentSpec,
      executedExpectationsCount: specResult.failedExpectations.length + specResult.passedExpectations.length,
      passedExpectations: specResult.passedExpectations,
      properties: specResult.properties
    }

    // generate ordered list of (nested) suite names
    var suitePointer = currentSuite
    while (suitePointer.parent) {
      result.suite.unshift(suitePointer.name)
      suitePointer = suitePointer.parent
    }

    if (!result.success) {
      var steps = specResult.failedExpectations
      for (var i = 0, l = steps.length; i < l; i++) {
        result.log.push(formatFailedStep(steps[i]))
      }

      if (typeof window !== 'undefined' && window.location && window.location.origin) {
        // Report the name of fhe failing spec so the reporter can emit a debug url.
        result.debug_url = debugUrl(specResult.fullName)
      }
    }

    // When failSpecWithNoExpectations is true, Jasmine will report specs without expectations as failed
    if (result.executedExpectationsCount === 0 && specResult.status === 'failed') {
      result.success = false
      result.log.push('Spec has no expectations')
    }

    tc.result(result)
    delete specResult.startTime
  }
}

/**
 * Extract grep option from karma config
 * @param {[Array|string]} clientArguments The karma client arguments
 * @return {string} The value of grep option by default empty string
 */
var getGrepOption = function (clientArguments) {
  var grepRegex = /^--grep=(.*)$/

  if (Object.prototype.toString.call(clientArguments) === '[object Array]') {
    var indexOfGrep = indexOf(clientArguments, '--grep')

    if (indexOfGrep !== -1) {
      return clientArguments[indexOfGrep + 1]
    }

    return map(filter(clientArguments, function (arg) {
      return grepRegex.test(arg)
    }), function (arg) {
      return arg.replace(grepRegex, '$1')
    })[0] || ''
  } else if (typeof clientArguments === 'string') {
    var match = /--grep=([^=]+)/.exec(clientArguments)

    return match ? match[1] : ''
  }
}

var createRegExp = function (filter) {
  filter = filter || ''
  if (filter === '') {
    return new RegExp() // to match all
  }

  var regExp = /^[/](.*)[/]([gmixXsuUAJD]*)$/ // pattern to check whether the string is RegExp pattern

  var parts = regExp.exec(filter)
  if (parts === null) {
    return new RegExp(filter.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')) // escape functional symbols
  }

  var patternExpression = parts[1]
  var patternSwitches = parts[2]
  return new RegExp(patternExpression, patternSwitches)
}

function getGrepSpecsToRun (clientConfig, specs) {
  var grepOption = getGrepOption(clientConfig.args)
  if (grepOption) {
    var regExp = createRegExp(grepOption)
    return filter(specs, function specFilter (spec) {
      return regExp.test(spec.getFullName())
    })
  }
}

function parseQueryParams (location) {
  var params = {}
  if (location && Object.prototype.hasOwnProperty.call(location, 'search')) {
    var pairs = location.search.slice(1).split('&')
    for (var i = 0; i < pairs.length; i++) {
      var keyValue = pairs[i].split('=')
      params[decodeURIComponent(keyValue[0])] =
          decodeURIComponent(keyValue[1])
    }
  }
  return params
}

function getId (s) {
  return s.id
}

function getSpecsByName (specs, name) {
  specs = specs.filter(function (s) {
    return s.name.indexOf(name) !== -1
  })
  if (specs.length === 0) {
    throw new Error('No spec found with name: "' + name + '"')
  }
  return specs
}

function getDebugSpecToRun (location, specs) {
  var queryParams = parseQueryParams(location)
  var spec = queryParams.spec
  if (spec) {
    // A single spec has been requested by name for debugging.
    return getSpecsByName(specs, spec)
  }
}

function getSpecsToRunForCurrentShard (specs, shardIndex, totalShards) {
  if (specs.length < totalShards) {
    throw new Error(
      'More shards (' + totalShards + ') than test specs (' + specs.length +
      ')')
  }

  // Just do a simple sharding strategy of dividing the number of specs
  // equally.
  var firstSpec = Math.floor(specs.length * shardIndex / totalShards)
  var lastSpec = Math.floor(specs.length * (shardIndex + 1) / totalShards)
  return specs.slice(firstSpec, lastSpec)
}

function getShardedSpecsToRun (specs, clientConfig) {
  var shardIndex = clientConfig.shardIndex
  var totalShards = clientConfig.totalShards
  if (shardIndex != null && totalShards != null) {
    // Sharded mode - Run only the subset of the specs corresponding to the
    // current shard.
    return getSpecsToRunForCurrentShard(
      specs, Number(shardIndex), Number(totalShards))
  }
}

/**
 * Create jasmine spec filter
 * @param {Object} clientConfig karma config
 * @param {!Object} jasmineEnv
 */
var KarmaSpecFilter = function (clientConfig, jasmineEnv) {
  /**
   * Walk the test suite tree depth first and collect all test specs
   * @param {!Object} jasmineEnv
   * @return {!Array<string>} All possible tests.
   */
  function getAllSpecs (jasmineEnv) {
    var specs = []
    var stack = [jasmineEnv.topSuite()]
    var currentNode
    while ((currentNode = stack.pop())) {
      if (currentNode.children) {
        // jasmine.Suite
        stack = stack.concat(currentNode.children)
      } else if (currentNode.id) {
        // jasmine.Spec
        specs.unshift(currentNode)
      }
    }

    return specs
  }

  /**
   * Filter the specs with URL search params and config.
   * @param {!Object} location property 'search' from URL.
   * @param {!Object} clientConfig karma client config
   * @param {!Object} jasmineEnv
   * @return {!Array<string>}
   */
  function getSpecsToRun (location, clientConfig, jasmineEnv) {
    var specs = getAllSpecs(jasmineEnv).map(function (spec) {
      spec.name = spec.getFullName()
      return spec
    })

    if (!specs || !specs.length) {
      return []
    }

    return getGrepSpecsToRun(clientConfig, specs) ||
          getDebugSpecToRun(location, specs) ||
          getShardedSpecsToRun(specs, clientConfig) ||
          specs
  }

  this.specIdsToRun = new Set(getSpecsToRun(window.location, clientConfig, jasmineEnv).map(getId))

  this.matches = function (spec) {
    return this.specIdsToRun.has(spec.id)
  }
}

/**
 * Configure jasmine specFilter
 *
 * This function is invoked from the wrapper.
 * @see  adapter.wrapper
 *
 * @param {Object} config The karma config
 * @param {Object} jasmineEnv jasmine environment object
 */
var createSpecFilter = function (config, jasmineEnv) {
  var karmaSpecFilter = new KarmaSpecFilter(config, jasmineEnv)

  var originalSpecFilter = jasmineEnv.configuration().specFilter
  var specFilter = function (spec) {
    return originalSpecFilter(spec) && karmaSpecFilter.matches(spec)
  }

  return specFilter
}

/**
 * Karma starter function factory.
 *
 * This function is invoked from the wrapper.
 * @see  adapter.wrapper
 *
 * @param  {Object}   karma        Karma runner instance.
 * @param  {Object}   [jasmineEnv] Optional Jasmine environment for testing.
 * @return {Function}              Karma starter function.
 */
function createStartFn (karma, jasmineEnv) {
  // This function will be assigned to `window.__karma__.start`:
  return function () {
    var clientConfig = karma.config || {}
    var jasmineConfig = clientConfig.jasmine || {}

    jasmineEnv = jasmineEnv || window.jasmine.getEnv()

    jasmineConfig.specFilter = createSpecFilter(clientConfig, jasmineEnv)
    jasmineEnv.configure(jasmineConfig)

    window.jasmine.DEFAULT_TIMEOUT_INTERVAL = jasmineConfig.timeoutInterval ||
      window.jasmine.DEFAULT_TIMEOUT_INTERVAL
    jasmineEnv.addReporter(new KarmaReporter(karma, jasmineEnv))
    jasmineEnv.execute()
  }
}

function indexOf (collection, find, i /* opt */) {
  if (collection.indexOf) {
    return collection.indexOf(find, i)
  }

  if (i === undefined) { i = 0 }
  if (i < 0) { i += collection.length }
  if (i < 0) { i = 0 }
  for (var n = collection.length; i < n; i++) {
    if (i in collection && collection[i] === find) {
      return i
    }
  }
  return -1
}

function filter (collection, filter, that /* opt */) {
  if (collection.filter) {
    return collection.filter(filter, that)
  }

  var other = []
  var v
  for (var i = 0, n = collection.length; i < n; i++) {
    if (i in collection && filter.call(that, v = collection[i], i, collection)) {
      other.push(v)
    }
  }
  return other
}

function map (collection, mapper, that /* opt */) {
  if (collection.map) {
    return collection.map(mapper, that)
  }

  var other = new Array(collection.length)
  for (var i = 0, n = collection.length; i < n; i++) {
    if (i in collection) {
      other[i] = mapper.call(that, collection[i], i, collection)
    }
  }
  return other
}

window.__karma__.start = createStartFn(window.__karma__)

})(typeof window !== 'undefined' ? window : global);
        ’  x’om   20230310033340-8lm   http://localhost:9876/base/node_modules/karma-jasmine/lib/adapter.js?db55991565c0f0381ab0fb3c340df5194b4bef99   ¯>  (function(window) {

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "(createSpecFilter|createStartFn)" }] */

'use strict'

// Save link to native Date object
// before it might be mocked by the user
var _Date = Date

/**
 * Decision maker for whether a stack entry is considered external to jasmine and karma.
 * @param  {String}  entry Error stack entry.
 * @return {Boolean}       True if external, False otherwise.
 */
function isExternalStackEntry (entry) {
  return !!entry &&
  // entries related to jasmine and karma-jasmine:
  !/\/(jasmine-core|karma-jasmine)\//.test(entry) &&
  // karma specifics, e.g. "at http://localhost:7018/karma.js:185"
  !/\/(karma.js|context.html):/.test(entry)
}

/**
 * Returns relevant stack entries.
 * @param  {Array} stack frames
 * @return {Array}        A list of relevant stack entries.
 */
function getRelevantStackFrom (stack) {
  var filteredStack = []
  var relevantStack = []

  for (var i = 0; i < stack.length; i += 1) {
    if (isExternalStackEntry(stack[i])) {
      filteredStack.push(stack[i])
    }
  }

  // If the filtered stack is empty, i.e. the error originated entirely from within jasmine or karma, then the whole stack
  // should be relevant.
  if (filteredStack.length === 0) {
    filteredStack = stack
  }

  for (i = 0; i < filteredStack.length; i += 1) {
    if (filteredStack[i]) {
      relevantStack.push(filteredStack[i])
    }
  }

  return relevantStack
}

/**
 * Custom formatter for a failed step.
 *
 * Different browsers report stack trace in different ways. This function
 * attempts to provide a concise, relevant error message by removing the
 * unnecessary stack traces coming from the testing framework itself as well
 * as possible repetition.
 *
 * @see    https://github.com/karma-runner/karma-jasmine/issues/60
 * @param  {Object} step Step object with stack and message properties.
 * @return {String}      Formatted step.
 */
function formatFailedStep (step) {
  var relevantMessage = []
  var relevantStack = []

  // Safari/Firefox seems to have no stack trace,
  // so we just return the error message and if available
  // construct a stacktrace out of filename and lineno:
  if (!step.stack) {
    if (step.filename) {
      var stackframe = step.filename
      if (step.lineno) {
        stackframe = stackframe + ':' + step.lineno
      }
      relevantStack.push(stackframe)
    }
    relevantMessage.push(step.message)
    return relevantMessage.concat(relevantStack).join('\n')
  }

  // Remove the message prior to processing the stack to prevent issues like
  // https://github.com/karma-runner/karma-jasmine/issues/79
  var stackframes = step.stack.split('\n')
  var messageOnStack = null
  if (stackframes[0].indexOf(step.message) !== -1) {
    // Remove the message if it is in the stack string (eg Chrome)
    messageOnStack = stackframes.shift()
  }
  // Filter frames
  var relevantStackFrames = getRelevantStackFrom(stackframes)
  if (messageOnStack) {
    // Put the message back if we removed it.
    relevantStackFrames.unshift(messageOnStack)
  } else {
    // The stack did not have the step.message so add it.
    relevantStackFrames.unshift(step.message)
  }

  return relevantStackFrames.join('\n')
}

function debugUrl (description) {
  // A link to re-run just one failed test case.
  return window.location.origin + '/debug.html?spec=' + encodeURIComponent(description)
}

function SuiteNode (name, parent) {
  this.name = name
  this.parent = parent
  this.children = []

  this.addChild = function (name) {
    var suite = new SuiteNode(name, this)
    this.children.push(suite)
    return suite
  }
}

function processSuite (suite, pointer) {
  var child
  var childPointer

  for (var i = 0; i < suite.children.length; i++) {
    child = suite.children[i]

    if (child.children) {
      childPointer = pointer[child.description] = { _: [] }
      processSuite(child, childPointer)
    } else {
      if (!pointer._) {
        pointer._ = []
      }
      pointer._.push(child.description)
    }
  }
}

function getAllSpecNames (topSuite) {
  var specNames = {}

  processSuite(topSuite, specNames)

  return specNames
}

/**
 * Very simple reporter for Jasmine.
 */
function KarmaReporter (tc, jasmineEnv) {
  var currentSuite = new SuiteNode()

  var startTimeCurrentSpec = new _Date().getTime()

  function handleGlobalErrors (result) {
    if (result.failedExpectations && result.failedExpectations.length) {
      var message = 'An error was thrown in afterAll'
      var steps = result.failedExpectations
      for (var i = 0, l = steps.length; i < l; i++) {
        message += '\n' + formatFailedStep(steps[i])
      }

      tc.error(message)
    }
  }

  /**
   * Jasmine 2.0 dispatches the following events:
   *
   *  - jasmineStarted
   *  - jasmineDone
   *  - suiteStarted
   *  - suiteDone
   *  - specStarted
   *  - specDone
   */

  this.jasmineStarted = function (data) {
    // TODO(vojta): Do not send spec names when polling.
    tc.info({
      event: 'jasmineStarted',
      total: data.totalSpecsDefined,
      specs: getAllSpecNames(jasmineEnv.topSuite())
    })
  }

  this.jasmineDone = function (result) {
    result = result || {}

    // Any errors in top-level afterAll blocks are given here.
    handleGlobalErrors(result)

    // Remove functions from called back results to avoid IPC errors in Electron
    // https://github.com/twolfson/karma-electron/issues/47
    var cleanedOrder
    if (result.order) {
      cleanedOrder = {}
      var orderKeys = Object.getOwnPropertyNames(result.order)
      for (var i = 0; i < orderKeys.length; i++) {
        var orderKey = orderKeys[i]
        if (typeof result.order[orderKey] !== 'function') {
          cleanedOrder[orderKey] = result.order[orderKey]
        }
      }
    }

    tc.complete({
      order: cleanedOrder,
      coverage: window.__coverage__
    })
  }

  this.suiteStarted = function (result) {
    currentSuite = currentSuite.addChild(result.description)
    tc.info({
      event: 'suiteStarted',
      result: result
    })
  }

  this.suiteDone = function (result) {
    // In the case of xdescribe, only "suiteDone" is fired.
    // We need to skip that.
    if (result.description !== currentSuite.name) {
      return
    }

    // Any errors in afterAll blocks are given here, except for top-level
    // afterAll blocks.
    handleGlobalErrors(result)

    currentSuite = currentSuite.parent

    tc.info({
      event: 'suiteDone',
      result: result
    })
  }

  this.specStarted = function () {
    startTimeCurrentSpec = new _Date().getTime()
  }

  this.specDone = function (specResult) {
    var skipped = specResult.status === 'disabled' || specResult.status === 'pending' || specResult.status === 'excluded'
    var result = {
      fullName: specResult.fullName,
      description: specResult.description,
      id: specResult.id,
      log: [],
      skipped: skipped,
      disabled: specResult.status === 'disabled' || specResult.status === 'excluded',
      pending: specResult.status === 'pending',
      success: specResult.failedExpectations.length === 0,
      suite: [],
      time: skipped ? 0 : new _Date().getTime() - startTimeCurrentSpec,
      executedExpectationsCount: specResult.failedExpectations.length + specResult.passedExpectations.length,
      passedExpectations: specResult.passedExpectations,
      properties: specResult.properties
    }

    // generate ordered list of (nested) suite names
    var suitePointer = currentSuite
    while (suitePointer.parent) {
      result.suite.unshift(suitePointer.name)
      suitePointer = suitePointer.parent
    }

    if (!result.success) {
      var steps = specResult.failedExpectations
      for (var i = 0, l = steps.length; i < l; i++) {
        result.log.push(formatFailedStep(steps[i]))
      }

      if (typeof window !== 'undefined' && window.location && window.location.origin) {
        // Report the name of fhe failing spec so the reporter can emit a debug url.
        result.debug_url = debugUrl(specResult.fullName)
      }
    }

    // When failSpecWithNoExpectations is true, Jasmine will report specs without expectations as failed
    if (result.executedExpectationsCount === 0 && specResult.status === 'failed') {
      result.success = false
      result.log.push('Spec has no expectations')
    }

    tc.result(result)
    delete specResult.startTime
  }
}

/**
 * Extract grep option from karma config
 * @param {[Array|string]} clientArguments The karma client arguments
 * @return {string} The value of grep option by default empty string
 */
var getGrepOption = function (clientArguments) {
  var grepRegex = /^--grep=(.*)$/

  if (Object.prototype.toString.call(clientArguments) === '[object Array]') {
    var indexOfGrep = indexOf(clientArguments, '--grep')

    if (indexOfGrep !== -1) {
      return clientArguments[indexOfGrep + 1]
    }

    return map(filter(clientArguments, function (arg) {
      return grepRegex.test(arg)
    }), function (arg) {
      return arg.replace(grepRegex, '$1')
    })[0] || ''
  } else if (typeof clientArguments === 'string') {
    var match = /--grep=([^=]+)/.exec(clientArguments)

    return match ? match[1] : ''
  }
}

var createRegExp = function (filter) {
  filter = filter || ''
  if (filter === '') {
    return new RegExp() // to match all
  }

  var regExp = /^[/](.*)[/]([gmixXsuUAJD]*)$/ // pattern to check whether the string is RegExp pattern

  var parts = regExp.exec(filter)
  if (parts === null) {
    return new RegExp(filter.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')) // escape functional symbols
  }

  var patternExpression = parts[1]
  var patternSwitches = parts[2]
  return new RegExp(patternExpression, patternSwitches)
}

function getGrepSpecsToRun (clientConfig, specs) {
  var grepOption = getGrepOption(clientConfig.args)
  if (grepOption) {
    var regExp = createRegExp(grepOption)
    return filter(specs, function specFilter (spec) {
      return regExp.test(spec.getFullName())
    })
  }
}

function parseQueryParams (location) {
  var params = {}
  if (location && Object.prototype.hasOwnProperty.call(location, 'search')) {
    var pairs = location.search.slice(1).split('&')
    for (var i = 0; i < pairs.length; i++) {
      var keyValue = pairs[i].split('=')
      params[decodeURIComponent(keyValue[0])] =
          decodeURIComponent(keyValue[1])
    }
  }
  return params
}

function getId (s) {
  return s.id
}

function getSpecsByName (specs, name) {
  specs = specs.filter(function (s) {
    return s.name.indexOf(name) !== -1
  })
  if (specs.length === 0) {
    throw new Error('No spec found with name: "' + name + '"')
  }
  return specs
}

function getDebugSpecToRun (location, specs) {
  var queryParams = parseQueryParams(location)
  var spec = queryParams.spec
  if (spec) {
    // A single spec has been requested by name for debugging.
    return getSpecsByName(specs, spec)
  }
}

function getSpecsToRunForCurrentShard (specs, shardIndex, totalShards) {
  if (specs.length < totalShards) {
    throw new Error(
      'More shards (' + totalShards + ') than test specs (' + specs.length +
      ')')
  }

  // Just do a simple sharding strategy of dividing the number of specs
  // equally.
  var firstSpec = Math.floor(specs.length * shardIndex / totalShards)
  var lastSpec = Math.floor(specs.length * (shardIndex + 1) / totalShards)
  return specs.slice(firstSpec, lastSpec)
}

function getShardedSpecsToRun (specs, clientConfig) {
  var shardIndex = clientConfig.shardIndex
  var totalShards = clientConfig.totalShards
  if (shardIndex != null && totalShards != null) {
    // Sharded mode - Run only the subset of the specs corresponding to the
    // current shard.
    return getSpecsToRunForCurrentShard(
      specs, Number(shardIndex), Number(totalShards))
  }
}

/**
 * Create jasmine spec filter
 * @param {Object} clientConfig karma config
 * @param {!Object} jasmineEnv
 */
var KarmaSpecFilter = function (clientConfig, jasmineEnv) {
  /**
   * Walk the test suite tree depth first and collect all test specs
   * @param {!Object} jasmineEnv
   * @return {!Array<string>} All possible tests.
   */
  function getAllSpecs (jasmineEnv) {
    var specs = []
    var stack = [jasmineEnv.topSuite()]
    var currentNode
    while ((currentNode = stack.pop())) {
      if (currentNode.children) {
        // jasmine.Suite
        stack = stack.concat(currentNode.children)
      } else if (currentNode.id) {
        // jasmine.Spec
        specs.unshift(currentNode)
      }
    }

    return specs
  }

  /**
   * Filter the specs with URL search params and config.
   * @param {!Object} location property 'search' from URL.
   * @param {!Object} clientConfig karma client config
   * @param {!Object} jasmineEnv
   * @return {!Array<string>}
   */
  function getSpecsToRun (location, clientConfig, jasmineEnv) {
    var specs = getAllSpecs(jasmineEnv).map(function (spec) {
      spec.name = spec.getFullName()
      return spec
    })

    if (!specs || !specs.length) {
      return []
    }

    return getGrepSpecsToRun(clientConfig, specs) ||
          getDebugSpecToRun(location, specs) ||
          getShardedSpecsToRun(specs, clientConfig) ||
          specs
  }

  this.specIdsToRun = new Set(getSpecsToRun(window.location, clientConfig, jasmineEnv).map(getId))

  this.matches = function (spec) {
    return this.specIdsToRun.has(spec.id)
  }
}

/**
 * Configure jasmine specFilter
 *
 * This function is invoked from the wrapper.
 * @see  adapter.wrapper
 *
 * @param {Object} config The karma config
 * @param {Object} jasmineEnv jasmine environment object
 */
var createSpecFilter = function (config, jasmineEnv) {
  var karmaSpecFilter = new KarmaSpecFilter(config, jasmineEnv)

  var originalSpecFilter = jasmineEnv.configuration().specFilter
  var specFilter = function (spec) {
    return originalSpecFilter(spec) && karmaSpecFilter.matches(spec)
  }

  return specFilter
}

/**
 * Karma starter function factory.
 *
 * This function is invoked from the wrapper.
 * @see  adapter.wrapper
 *
 * @param  {Object}   karma        Karma runner instance.
 * @param  {Object}   [jasmineEnv] Optional Jasmine environment for testing.
 * @return {Function}              Karma starter function.
 */
function createStartFn (karma, jasmineEnv) {
  // This function will be assigned to `window.__karma__.start`:
  return function () {
    var clientConfig = karma.config || {}
    var jasmineConfig = clientConfig.jasmine || {}

    jasmineEnv = jasmineEnv || window.jasmine.getEnv()

    jasmineConfig.specFilter = createSpecFilter(clientConfig, jasmineEnv)
    jasmineEnv.configure(jasmineConfig)

    window.jasmine.DEFAULT_TIMEOUT_INTERVAL = jasmineConfig.timeoutInterval ||
      window.jasmine.DEFAULT_TIMEOUT_INTERVAL
    jasmineEnv.addReporter(new KarmaReporter(karma, jasmineEnv))
    jasmineEnv.execute()
  }
}

function indexOf (collection, find, i /* opt */) {
  if (collection.indexOf) {
    return collection.indexOf(find, i)
  }

  if (i === undefined) { i = 0 }
  if (i < 0) { i += collection.length }
  if (i < 0) { i = 0 }
  for (var n = collection.length; i < n; i++) {
    if (i in collection && collection[i] === find) {
      return i
    }
  }
  return -1
}

function filter (collection, filter, that /* opt */) {
  if (collection.filter) {
    return collection.filter(filter, that)
  }

  var other = []
  var v
  for (var i = 0, n = collection.length; i < n; i++) {
    if (i in collection && filter.call(that, v = collection[i], i, collection)) {
      other.push(v)
    }
  }
  return other
}

function map (collection, mapper, that /* opt */) {
  if (collection.map) {
    return collection.map(mapper, that)
  }

  var other = new Array(collection.length)
  for (var i = 0, n = collection.length; i < n; i++) {
    if (i in collection) {
      other[i] = mapper.call(that, collection[i], i, collection)
    }
  }
  return other
}

window.__karma__.start = createStartFn(window.__karma__)

})(typeof window !== 'undefined' ? window : global);
Ó˜ÀÙ¬   §        ø2‡‰      window     ½ˆø’      _Date      ó5«      isExternalStackEntry   M»“>      entry      …æ¥„       \/(jasmine-core|karma-jasmine)\/   4?`      \/(karma.js|context.html):     ¾#r      getRelevantStackFrom   ä1E      filteredStack      &Úı@      relevantStack	      ğ„u2      push
   ú»¾      formatFailedStep   ®6nn      step   MK      relevantMessage    ~ë@b      filename   ¼§K*
      stackframe     s‘­      lineno     ¦¢‚      concat     Æv”x      stackframes    ;
úƒ      messageOnStack     ÚEœÁ      indexOf    ‚=ŠO      shift      ÁÒ:*      relevantStackFrames    Y¾l      unshift    ^o‘4      debugUrl   „ˆš      description    0+QA      location   =¨€;      origin     %e[Â      /debug.html?spec=      '¿N^	      SuiteNode      şèù2      parent     
}N      children   ‚@ˆÅ      addChild    ¾ÁQ      suite!      qmZØ      processSuite"   ùéØ9      pointer#    Qj^      child$      PËƒ³      childPointer%   hÜ„>      getAllSpecNames&    şÊçü      topSuite'   iHÆ	      specNames(      1s˜      KarmaReporter)      ñ…è
      jasmineEnv*     dåµ      currentSuite+   g¼È      startTimeCurrentSpec,   uô.      getTime-    #rQ      handleGlobalErrors.     ÉŠbÇ      failedExpectations/     [È      An error was thrown in afterAll0    ND‰ß      steps1      ştuW      error2      æ.ˆŞ      jasmineStarted3     6—(      data4   üõä      info5   II·P      event6      Tı»W      total7      å®Yü      totalSpecsDefined8      šà      specs9      ¿Ô*      jasmineDone:    5şÑö      cleanedOrder;   vÍ†      order<      $	      orderKeys=      L9€      orderKey>   D•È‡      complete?   ‰z™`      coverage@   !N›      __coverage__A   KE˜¸      suiteStartedB   Ä!€	      suiteDoneC      )F>      specStartedD    ƒ,šÌ      specDoneE   ¨Œ
      specResultF     oÙU      skippedG    zƒw      disabledH   T7Ø0      excludedI   D±Â      fullNameJ   =Xû      logK    É©\9      successL    €%]ü      timeM   )“       executedExpectationsCountN      PSÖ      passedExpectationsO     ¿Û
      propertiesP     ï{j      suitePointerQ   ¤ÙI	      debug_urlR      ™ÖŸl      failedS     »%\Ú      Spec has no expectationsT   ÀI¼«	      startTimeU      ƒ}"¼      getGrepOptionV      ™^×x      clientArgumentsW    ğ½	      grepRegexX      #’}ç      ^--grep=(.*)$Y      œ$í      indexOfGrepZ    W¦E~      --grep[     9Ì      map\    >	Å      filter]     6ñ‘      arg^    <       --grep=([^=]+)_     ,ÄÏ      createRegExp`   7Ÿì–      regExpa     ¬É:-      ^[/](.*)[/]([gmixXsuUAJD]*)$b   !ÓT÷      partsc      –'Á      [-[\]{}()*+?.,\\^$|#\s]d    {Sş8      \$&e    [ oí      patternExpressionf      ‡Ùü      patternSwitchesg    H{ºÇ      getGrepSpecsToRunh      4xX      clientConfigi   µUZ 
      grepOptionj     ÜÙœÉ      argsk   n$ğ
      specFilterl     ´ì      specm   ®öÖó      getFullNamen    …$¹      parseQueryParamso   ËË&<      paramsp     ëóø      pairsq      Ø… Ì      slicer      ö[0      keyValues   'ç       getIdt      ~©ú—      getSpecsByNameu     œ‡öÓ      No spec found with name: "v     ù•¸o      getDebugSpecToRunw      8'],      queryParamsx    uî		      getSpecsToRunForCurrentShardy   ¨Ób
      shardIndexz     3á      totalShards{    d>.z      More shards (|      ¤í´ü      ) than test specs (}    êz1-	      firstSpec~      `-„—      floor      ±'R      lastSpec€   ¸€q¡      getShardedSpecsToRun   {÷nW      KarmaSpecFilter‚    S˜k˜      getAllSpecsƒ    Åá®S      currentNode„    ¦i4      pop…    ·M#Ô      getSpecsToRun†      áG˜ò      specIdsToRun‡   ¨ÑÏ~      matchesˆ    -$ñS      createSpecFilter‰   ~4      configŠ     áºà      karmaSpecFilter‹    Ê¤iì      originalSpecFilterŒ     RÅW      configuration      ıš°D      createStartFn      "Ãˆ      karma      xzğ      jasmineConfig      c¶–µ      jasmine‘    Ry9      getEnv’     Ú_¢	      configure“      ëÆıC      DEFAULT_TIMEOUT_INTERVAL”   ‰¨      timeoutInterval•    î.ÒÂ      addReporter–    ïÆİ~      execute—    íö±‘
      collection˜     ö½hy      that™   ÛÍV      mapperš     cá°ÿ	      __karma__›      @mó      SuiteNode/this.addChild    —ğåÆ!      KarmaReporter/this.jasmineStarted      -ZX      KarmaReporter/this.jasmineDoneŸ     ±-òh      KarmaReporter/this.suiteStarted     ¯ÉÒ      KarmaReporter/this.suiteDone¡   tğVK      KarmaReporter/this.specStarted¢      '%      KarmaReporter/this.specDone£    ÛÚ—ğ      getGrepOption/<¥    yçN      getSpecsByName/specs<¨      Uqw™$      KarmaSpecFilter/getSpecsToRun/specs<©   nóhB      KarmaSpecFilter/this.matches«   ÂÃE      createStartFn/<     +   0  ,   +             ï%,‰                                                                                                                                                                         	                
      
                 
                 
                 
                 
                 
                 
                                                                                                                                                                                                  &                 '                 (                 )                 *                      !                 !                                                  %                  %           !      '           "      %           #                $      *           %      ³OŒc                           PU  P(  P  Pg  Pt  P  P  P  P[  P\  P%  Pv  Pn  Pˆ  P_  P€  P  x  P
  P  P  P  Ps  P!  P                           —      i                                                       +    o               +     o                  "  #  $  i              &  '              L`)  P*  P+  P-  Po               z    0  i  l               3              z  :  <  i  =               z               z                              E  F  z  P  0  i  l              h  8  i  `  P          k               l                o  p  i  r               s               8  + `             s                8  w  l              8  y  z  }                8  h  y  z                 P)  P              h                —     i  n              —  \  ˜  R  v  i  n              —  ™  ˜  R  i  n              V  W  PY  U               ]               ]              \  `  b  e  f              h  )  ‚  P…  o               )  8  —  ƒ                h  )  8               l              l  o               ‰  )  Š  P‹  Pk               l  ¯Â0°            X      ^      a      c     Iô$KE®úš         _                 5  6  8                     
     ;  ?     
    5  z     
    5  z     A    I     J  F  G  Z  K     L  M  N  O                          ‡&Õª!«!+   p   p   :                          j    ´      –   “   ´   •   “   ´   “   t Õ¡ `PF€ 3 ¯ ÿÿÿÿP4P ˆ  ˆ  *                       j   Ä   Õj   Ä   Õj   Ä   Õj   Ä   Õj   Ä   Õj   Ä   Õj   Ä   Õj   Ä   Õj	   Ä   Õj
   Ä   Õj   Ä   Õj   Ä   Õj   Ä   Õj   Ä   Õj   Ä   Õj   Ã   Õj   Ä 
  Õj   Ä   Õj   Ä   Õ´   Ä   Õj   Ä   Õj   Ä   Õj   Ä 	  Õj   Ä   Õ·   H   ¶    ·   H   p K   Õ¡ÿÑ@@ `PK€ + `PK€ A `PK€ Ÿ `PK€ İ `PK€ 1`P™ P90P „   „   H                  
       µ  ˜<   “   Õi   ×H   Úµ  p ˜   “   Õi   ×H   Úµ  p “
   ¡0 `P  @ /$PO /P9Q À                           e    Ã   Õe    Ã  ÕÃ  Õ”   ¶  µ  H   –Q   “   ·    µ  ¶  Ip –!   “   ¶   ×H   Úµ  ¶  It Õ“   ¶  %Ã  Õ•¡ÿÿÿ“   ¶   H   –   “   µ  Ã   Õ“   Ã  Õ”   ¶  ¶   H   –J   “   ¶   ¶  I–"   “   ¶  ×H   Ú¶   ¶  It Õ“   ¶  %Ã  Õ•§ÿÿÿ“   ¶  ¡0 `P: `PJ  `P&fP—0 `P.P= `P“ PI $`P@ `P•0 `PM `P&fP˜0 `P“0 `P” PI (`P@ `P4Q À            d          «   ^   T  T  —         	       )       e    Ã   Õe    Ã  Õµ  H   —©   “   µ  H   –Y   “   µ  H   Ã  Õµ  H   –"   “	   ¶     %µ  H   %Ã  Õ“   ¶  ×H   Ú¶  t Õ“   ¶   ×H   Úµ  H   t Õ¶   ×H   Ú¶  p ×H   Ú	   p “   µ  H   ×H
   Ú	   p Ã  ÕÃ  Õ¶  I×H   Úµ  H   p ÿ–   “   ¶  ×H   Úp  Ã  Õ“    ·    ¶  p Ã  Õ¶  –"   “"   ¶  ×H   Ú¶  t Õ•!   “$   ¶  ×H   Úµ  H   t Õ“'   ¶  ×H   Ú	   p ¡0 `P: `PJ `P’0 `P’0 `P= 
`P’0 `P@ `P/PI `P“ P4 `P/P/PC&F `P” P8 `P6 `P• P@ `P+PM `P*P8 `PN `P/P>@" `P“ PI% `P P3Q    T   T   $                         ·   H   H      %´    µ  p %¡@ `P 6P4Q   |   |   ?                       ÔÃ   Õ¶   µ  K   Õ¶   µ K   Õ¶   e    K   Õ¶   j   K   Õ¡6 `P= `P= `PO `PO
P    x   x   =                       ÔÃ  Õ·   }µ  ¶  Ù  ~ Ã   Õ¶  H   ×H   Ú¶   t Õ¶   ¡6 `P™0 `P” P4 `P4 Q  l  \  æ                       Ã  Õ”    ¶  µ  H   H   –Â   “   µ  H   ¶  IÃ   Õ¶   H   –B   “   µ ¶   H   7   e    :   MÃ  Õ·    ¶   ¶  t Õ•K   “   µ H   —   “   µ e    K   Õ“   µ H   ×H   Ú¶   H   t Õ“   ¶  .'Ã  Õ•+ÿÿÿ“   ¡00@  `P&fPœ0 `P’@ `P“0 `P‘ .0 `P.P>0 
`P’0 `P“@ `P˜ 
PI -`P•@P   l            Ú   \   \   !                        7   Ã   Õ·    µ  ¶   t Õ¶   ¡0 `PJ `P-PD `P4Q    ü   ü   œ                
       ÔÃ   Õj   Ä   Õ·  }Ù  ~  Ä   Õ·  }Ù  ~  ×H   Úp  Ä   Õ¶   j   K   Õ¶   j   K   Õ¶   j   K   Õ¶   j	   K
   Õ¶   j   K   Õ¶   j   K   Õ¡‘0 `P“@ `P” PI `PO% `PO? `POG `POZ `PO^ `PO€  ŒP    <  ,  Ä          
             µ  H   ˜   “   Õµ  H   H   “   –™   “      Ã   Õµ  H   Ã  ÕÃ  Õ¶  H   Ã  Õ”   ¶  ¶  –<   “	   ¶      ·   ¶  ¶  Ip %%Ã   Õ¶  .'Ã  Õ•ºÿÿÿ“   ·   ×H   Ú¶   t Õ“   ¡0 `P¯0 `P: `P=  `P&`P.fP“0 `P˜ PF /`P•@ `P PI
 P   <         Z   K         J                  
       ·   ×H   Ú7      :   µ  H   :   ·   ·   ×H   Úp  p :   t Õ¡@ `P‘0 : = ’ "P#ÿÿÿåPH PD P ¨  ˜                        µ  ™   “   Õ7   “   Â  Õ·    µ  t Õµ  H   –¬   “   7   Ã   Õ´   ×H   Úµ  H   p Ã  ÕÃ  Õ”
   ¶  ¶  H   –b   “   ¶  ¶  IÃ  Õµ  H   ¶  I   –!   “   ¶   ¶  µ  H   ¶  IMÕ“   ¶  .'Ã  Õ•ÿÿÿ“   ·   ×H   Ú7	   ¶   :   ·  H
   :   t Õ¡0 `Pœ@ `P)PD0 `P’0 `P: `P” P8  `P&fP˜0 `P> `P0 
`Pœ@ ,`P•@ `P‘0 9 O PD P   ¨         g   v   ˆ   ˆ   E                         ·   ×H   Úµ  H   p Ä   Õ·   ×H   Ú7      :   µ  :   t Õ¡0 `P” P9 `P‘0 : H PD P   Ä   Ä   i                         µ  H   ·   H   –   “    “   ·    µ  t Õ·   H   Ä   Õ·   ×H   Ú7      :   µ  :   t Õ¡@ `P0 `PA F	 `P)PD `P@ `P‘0 : H PD P   P   P                             ·  }Ù  ~  ×H   Úp  Ä   Õ¡0 `P*P*P9 P  <    .                \      µ  H      ™2   “   Õµ  H      ™   “   Õµ  H      “   Ã   Õ7   µ  H   :   µ  H   :   µ  H   :   e    :	   ¶   :
   µ  H      ™   “   Õµ  H      “   :   µ  H      :   µ  H   H   :   e    :   ¶   –   “"   •'   “"   ·  }Ù  ~  ×H   Úp  ·   &“&   :   µ  H   H   µ  H   H   %:   µ  H   :   µ  H   :   Ã  Õ·   Ã  Õ”1   ¶  H   –:   “3   ¶  H   ×H   Ú¶  H   t Õ¶  H   Ã  Õ•¼ÿÿÿ“8   ¶  H   —ä   “:   µ  H   Ã  ÕÃ  Õ¶  H   Ã  Õ”<   ¶  ¶  –@   “>   ¶  H	   ×H   Ú·   ¶  ¶  Ip t Õ¶  .'Ã  Õ•¶ÿÿÿ“E   ·     ˜/   “H   Õ·  H   ˜   “J   Õ·  H   H   “L   –%   “M   ¶  ·   µ  H   p K   Õ“P   ¶  H   ˜   “S   Õµ  H      “U   –.   “V   ¶  K   Õ¶  H	   ×H   Ú   t Õ“Z   ·   ×H   Ú¶  t Õµ  O   Õ¡0 `PÊ0 `P5 = = = : 9 ±0 “0 ”0 : £ P*P“0  0 = ’@ `P: fP“0 `P™ P4 `P˜@ `P“0 `P=  `P&`P.fP“0 `PŸ P#ÿÿÿûPD /`P•@ 
`PÊ@! `P’ PN& `P³0 `P; `P• PI+ `P P4 `P9 P    <         t  I          ö  O   €  €  	                       i   Ä   Õ´   H   H   ×H   Úµ  p    –}   “   ·
   µ     p Ã   Õ¶   ÿ–   “
   µ  ¶   %I“   ·   ·   µ  j   p j	   p I™   “   Õ
   “   •^   “   µ     –J   “   i   ×H   Úµ  p Ã  Õ¶  –   “   ¶  I•   “   
   “   “   ¡0 `PK `P™ P“0 `P.PH `P‘0 `PJF
 `P” P(ÿÿÿüPC—@K `P”0 `P/PH `P¨@V  D   D                            ·   ×H   Úµ  p ¡0 `P/P3 Q   H   H                            µ  ×H   Ú·      p ¡0 `P” P3 Q @  @  Ê          
              µ  ™   “   Õ   “   Â  Õµ     –   “   ´   }Ù  ~  “   i   Ã   Õ¶   ×H   Úµ  p Ã  Õ¶  –/   “	   ´   }µ  ×H   Úi      p Ù  ~ “   ¶  IÃ  Õ¶  IÃ  Õ´   }¶  ¶  Ù  ~ ¡0 `Pœ0 `P“0 `P*PCF `PJ `P.P8 `P0 `Pš P'ÿÿÿîPCF `P; `P< `P’ P3Q   ”   ”   O                        ·   µ  H   p Ã   Õ¶   –/   “   ·   ¶   p Ä   Õ·   µ j   p “   ¡0 `P.P8 `P> `P*P9 `P.PCV    T   T                           ·   ×H   Úµ  ×H   Úp  p ¡0 `P– P#ÿÿÿöP3 Q  t  d  ï          
             7   Ã   Õµ  ˜,   “   Õ´   H   H   ×H   Úµ     p “   –¦   “   µ  H   ×H   Úp ×H   Ú	   p Ã  ÕÃ  Õ”   ¶  ¶  H
   –[   “   ¶  ¶  I×H   Ú   p Ã  Õ¶   ´    ¶  Ip ´    ¶  Ip MÕ¶  .'Ã  Õ•–ÿÿÿ“   ¶   ¡0 `P: `P¬ ,P’0 `P P/	P8 	 `P&fP˜0 `P• 	P8 `P P3,
PE &`P•@
 `P4Q    t         u   o   4   4   
                         µ  H   ¡0 `P8Q  ˜   ˜   S                  	       µ  ×H   Új   p Â  Õµ  H   –)   “   ´   }   ·   %   %Ù  ~ £“	   µ  ¡0 `P/PG `P”0 `P› PI `P3Q    L   L                            µ  H   ×H   Ú·   p ÿ¡0 `P” P6 Q  „   „   D                        ·    µ  p Ã   Õ¶   H   Ã  Õ¶  –   “   ·    µ ¶  p “   ¡0 `P)P8 `P> `PN `P-PCV ü   ü   ¨                        µ  H   µ –6   “   ´   }   µ %   %µ  H   %   %Ù  ~ £“
   ´   ×H   Úµ  H   µ )µ *p Ã   Õ´   ×H   Úµ  H   µ %)µ *p Ã  Õµ  ×H   Ú¶   ¶  p ¡0 `P–0 `P6˜0J 
PI	 `Pœ P8 `P P8 `P’ P3Q  ´   ´   m          	              µ H   Ã   Õµ H   Ã  Õ¶   ˜   “   Õ¶  “   –1   “   ·    µ  ´    ¶   p ´    ¶  p p “   ¡0 `P= `P= `P¦@ `P6-P-PC PC	V ¨   ¨   i         
              ÔÃ  Õj   Ä   Õj   Ã   Õ¶  ´   }¶    ·  H   µ  µ p ×H   Ú·  p Ù  ~ K   Õ¶  j   K   Õ¡›@. `PŸ P/9P'ÿÿÿ¿PI0 `PO3P 8  (  ¼                       e    Ã   Õe   µ  ×H   Úp  f    Ã  Õ”   ¶  ×H   Úp  Ã  –s   “   ¶  H   –+   “	   ¶  ×H   Ú¶  H   p Ã  Õ•0   “   ¶  H   –   “   ¶   ×H   Ú¶  t Õ“   •zÿÿÿ“   ¶   ¡0 `P: `P%*P=0 fP+P‘0 
`P“@ `P” P’0 `P“@
 `P/P“@ `P4 Q   8         &   ‹       °                        ·    µ p ×H   Új   p Ã   Õ¶   ™   “   Õ¶   H   “   –   “   e    “	   ·   µ ¶   p ™E   “   Õ·   µ  ¶   p ™*   “   Õ·   ¶   µ p ™   “   Õ¶   “   ¡0 `P)P/PH `P 
™0 `PE F
 `P-P>-
P>-
P>9 Q   P   P                            µ  µ  ×H   Úp  K   Õµ  ¡0 `P-P9 `P3 Q   T   T   #                       ÔÃ   Õ¶   H   ×H   Úµ  H   p ¡6 `P˜ P3 Q   €   €   A                        ·	  }µ  µ Ù  ~ Ä   Õµ ×H   Úp  H   Ä   Õj   Ã   Õ¶   ¡0 `P™@ `P*P> `PJ `P4Q  d   d   0                         ·    µ  p ˜   “   Õ·   ×H   Úµ  p “   ¡0 `P)P ,P8 Q   4   4                             j   ¡@ `PEQ   ˆ  ˆ           	               ·   H   ™   “   Õ7   “   Ã   Õ¶   H   ™   “   Õ7   “   Ã  Õ·   ™   “   Õ·  H   ×H   Úp  “
   Ä   Õ¶  ·   ¶   ·   p K   Õ·   ×H   Ú¶  t Õ·  H   ¶  H   ™   “   Õ·  H   H	   “   K	   Õ·   ×H
   Ú·  }·   ·   Ù  ~ t Õ·   ×H   Út  Õ¡0 `P¤0 `P£@ `P¡ *PN `P“ P9 `P PD	 `P0š0 `P  P#ÿÿÿôP4 `P,P4 P    „  t  ö                       µ  H   –   “   µ  ×H   Úµ µ p “   µ ´   –   “   Â Õ“   µ –   “	   µ µ  H   %Â Õ“   µ –   “   Â Õ“   µ  H   Ã   Õ”   µ ¶   –M   “   µ µ  !˜   “   Õµ  µ Iµ “   –   “   µ “   µ .'Â Õ•ªÿÿÿ“   ÿ¡0 `P’0 `P PCF `P“ `P: `P/	`P: `P/	`P:  `P-fP’0 `P¬0 `PCF )`P“@ `P2Q  „         ’   [   X  H  Ù          
             µ  H   –   “   µ  ×H   Úµ µ p “   e    Ã   ÕÃ  Õµ  H   Ã  Õ”   ¶  ¶  –w   “   ¶  µ  !˜.   “
   Õµ ×H   Úµ µ  ¶  IÃ  ¶  µ  p “   –   “   ¶   ×H   Ú¶  t Õ“   ¶  .'Ã  Õ•ÿÿÿ“   ¶   ¡0 `P’0 `P PCF `P:0  `P&`P-fP“0 `P³ P’0 `P/PI 0`P•@ `P4Q X         H   †   H  8  Ì                       µ  H   –   “   µ  ×H   Úµ µ p “   ´   }µ  H   Ù  ~ Ã   ÕÃ  Õµ  H   Ã  Õ”   ¶  ¶  –Z   “
   ¶  µ  !–3   “   ¶   ¶  µ ×H   Úµ µ  ¶  I¶  µ  p MÕ“   ¶  .'Ã  Õ•œÿÿÿ“   ¶   ¡0 `P’0 `P PCF `Pš0  `P&`P-fP“0 `P’0 `P¤ PJ 0`P•@ `P4Q H         X   i   3õØ  `   P«    P  `  	    `—      :  	      ş   
  Z          `      w     `  	    `+        p    `         @_  	  	  `  @  `.    /  
  1    `4    @2  5  7  6  &  8    `  @;    @  º       >    @@  ?    `    4    @A  5  z    `  +    4    @B  5  z    `,    `Ÿ  G  Z  H    @I     J  F  .    K     ,  L  N  M  O      +  	  ÿ      Q  R  S  z  T  
  `  p,    p2    p9    pA    pB    pC    pD    `  `«  m    `j    p  `	  @  g  Ì   1   W  q  Z  &    =  Y     `   `+      `\    p    u  "    `l    `    {  |  )    ~  q    `y  z      `‰  
  @    @‘  k  ’  ”  “  •  –    `'  p  `  ÿ      `\    1   	     `[  
    1   "  `«  #  `V   !  `  P  g  ¹  1   ?  Z    p  pt       Pƒ   $  `t       Pƒ   V    Pd  &  `&  „         (  `m  +  '  `[  "  p  )  `†  È    %  `   p!  p/    [  †  #  p‡  +  `‡  *  `Œ  k  %  p  `  p  p  p  p  p  p	  p
  p  p  p  p  p  p  p  p&  p(  p)  p*  p    p  p  p$  pš  š     `  p   ÿ  ¾   ÿX„+                                                                    
                                             ›        #      !         *      %         z      (         ,      -         2   	           ;              G      Ÿ        O   	            X      ¡        Z       ¢        Ù      U       
 Ô      £        Ö      £        ç      _       
       g         ‰      k              n               s         ¢      t         Ÿ      ¥        ©      v         «   	   x         ´      €           	          
 ï      ‚         ù      …         ö      ¨        ı      ©             ˆ       
 
     k       
 Ä               ¸      «        Æ               Ê      \         Ï      [         H©À      ¯>      ¯>                 € 	   {>     {>     	            Ñ  Ç  ³  Ç                 n  ¤  P  ¤                 ¤  Ÿ  Š  Ÿ  B               ³  M  ¡  M  j              b  5  O  5  o              Î  3  Å  3  t               M  È  7  È  {               ã  ?  Ê  ?               ‚ …  Ü   n  Ü   ™                 [  ô  [                 9    0    µ   !            +    "    ¾               #  µ    µ  Ø               Ó  p  Ê  p  à                 É  ‡  É  ó                æ  Ú   İ  Ú   ÷             € ·!  $  ®!  $  ,              ù"  '#  ğ"  '#  6  0            3#  j#  *#  j#  8              %$  &  $  &  B            € 4&  -'  &  -'  T              ë&  &'  ×&  &'  X  -            I'  µ(  /'  µ(  ^              Æ(  Û(  ·(  Û(  k            € õ(  Æ)  İ(  Æ)  o              %)  U)  )  U)  p               ã)  ½*  È)  ½*  y              å*  °,  ¿*  °,  ‚  &            Ğ,  9.  ²,  9.              ‚ Ì.  q4  Ã.  q4                 ¤/  1  /  1  ¦              ,2  ¹3  2  ¹3  ¾              ˆ2  Í2  2  Í2  ¿  5           94  o4  04  o4  Ğ            € l5  ‰6  c5  ‰6  Ş               !6  r6  6  r6  â            € Ü7  /:  Å7  /:  ó              E8  -:  <8  -:  õ               B:  —;  1:  —;                ©;  ë<  ™;  ë<                ú<  >>  í<  >>  $            5¡İ…}¬®­3îüÇ›      dÃ7dÃ7EaQIeõòƒ   ›    O^partitionKey=%28http%2Clocalhost%2C9876%29,:http://localhost:9876/base/node_modules/karma-jasmine/lib/adapter.js?db55991565c0f0381ab0fb3c340df5194b4bef99 necko:classified 1 strongly-framed 1 request-method GET response-head HTTP/1.1 200 OK
Content-Type: application/javascript
Cache-Control: public, max-age=31536000
Date: Fri, 17 Mar 2023 19:26:59 GMT
 original-response-headers Content-Type: application/javascript
Cache-Control: public, max-age=31536000
Date: Fri, 17 Mar 2023 19:26:59 GMT
Connection: keep-alive
Keep-Alive: timeout=5
Transfer-Encoding: chunked
 ctid 2 uncompressed-len 0 net-response-time-onstart 17 net-response-time-onstop 17 alt-data 1;16047,javascript/moz-script-bytecode-20230310033340-8l alt-data-from-child 1   ÑV